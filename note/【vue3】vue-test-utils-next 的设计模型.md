
# VTU 的设计模型

剖析 VTU 的项目结构设计

开始之前先思考一个问题

==测试一个组件的时候，要测试什么东西？==

## 目的

给组件一些属性，然后验证它运行后的结果？

对吧，这个没错把

那怎么验证组件的结果呢？

基于组件的属性来验证一些结果

那好，那如果直接访问组件的一些属性的话，是不是不太方便，不太简洁？

那我们想办法让它访问起来简单，使用起来快捷不就好了吗

好，到这里，其实我们就知道 VTU 它是做什么事情的了。

它其实就是为了让我们访问组件的属性简单、高效

那现在目的我们是知道了 那怎么做呢？

## 怎么做

怎么让我们访问组件的属性、方法变得更加简单、高效呢？

可以采用封装的方法啊，提高简单、高效的接口供用户调用

我们把内部的复杂或者通用处理逻辑封装起来

注意哦，这里是封装对组件的操作

而 VTU 是怎么做的

分为两步：

1. 先构建组件
	1. 这里的要点还是要简单简单在简单

2. 提供对组件简单高效的处理接口
	1. 内部访问组件的属性或者方法


用户通过接口来获取组件的属性或者方法来进行验证

这样的话， VTU 的模型就形成了

我们看看源码里面是怎么做的

### 源码是怎么做的

#### 构建组件

通过 mount 来构建组件

这里为什么要用 mount 其实还是为了让构建组件这个动作变得高效

调用 mount 的时候只需要一个 config 即可。

所有需要设置组件的一些复杂操作都封装在 mount 函数内部

用户不需要关心，这里其实就是减少了复杂度，让用户使用起来贼简单

#### 处理接口

所有的处理接口都在 vue-wrapper 或者 dom-wrapper 上。

> 当调用 mount 后会返回

那这两个是对象是个什么东西呢？

着两个对象就是对我们组件操作的一层封装

我们直接通过着两个对象提供的接口来完成高效的、简单的操作

## 总结

着就是 VTU 的设计模型了

其核心还就是封装

VTU 是 vue-test-utils-next 的简称